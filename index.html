<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#000000" />

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Turnos">

  <link rel="manifest" href="./manifest.webmanifest" />
  <link rel="apple-touch-icon" href="./icons/icon-192.png" />
  <title>Turnos</title>

  <style>
    :root{
      color-scheme: dark;
      --bg:#000;
      --text:#EAF0FF;
      --muted:#9CB0D6;

      --blue:#4EA6FF;
      --red:#FF4E6A;
      --amber:#FFD45A;
      --green:#5CF56F;

      --card: rgba(255,255,255,.04);
      --stroke: rgba(255,255,255,.08);

      --shadow: 0 18px 46px rgba(0,0,0,.68);
      --inset: inset 0 1px 0 rgba(255,255,255,.07), inset 0 -1px 0 rgba(0,0,0,.55);
      --r: 18px;

      --safeTop: env(safe-area-inset-top, 0px);
      --safeBottom: env(safe-area-inset-bottom, 0px);
    }

    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    body{
      margin:0;
      font-family: -apple-system, system-ui, Segoe UI, Roboto, Arial;
      color: var(--text);
      background: var(--bg);
      min-height: 100vh;
    }

    .wrap{
      max-width: 540px;
      margin: 0 auto;
      padding: calc(18px + var(--safeTop)) 16px calc(22px + var(--safeBottom));
      display:flex;
      flex-direction: column;
      gap: 14px;
    }

    .top{
      display:flex;
      align-items:flex-start;
      justify-content: space-between;
      gap: 12px;
      padding: 14px;
      border-radius: var(--r);
      background: var(--card);
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    .label{ font-size: 12px; color: var(--muted); }
    .now{ font-size: 30px; font-weight: 900; letter-spacing: -0.03em; line-height: 1.05; }
    .eta{ font-size: 18px; font-weight: 800; }
    .tiny{ font-size: 12px; color: rgba(234,240,255,.72); margin-top: 6px; }

    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      box-shadow: var(--inset);
      font-size: 12px;
    }
    .dot{ width:10px; height:10px; border-radius: 999px; display:inline-block; }

    .bgline{
      margin-top: 10px;
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      font-size: 12px;
      color: rgba(234,240,255,.9);
      display:none;
    }
    .bgline strong{ color:#fff; }

    .center{
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 10px 0;
    }

    .mainBtn{
      width: 260px;
      height: 260px;
      border-radius: 999px;
      position: relative;
      display:grid;
      place-items:center;
      border: 0;
      background: transparent;
      cursor:pointer;
      user-select:none;
      transform: translateZ(0);
      overflow: hidden; /* ripple */
      --accentColor: rgba(78,166,255,.95);
      --accentGlow: rgba(78,166,255,.35);
    }

    .ring{
      position:absolute;
      inset: 0;
      border-radius: 999px;
      background: conic-gradient(var(--ringFill) var(--p), rgba(255,255,255,.06) 0);
      filter: drop-shadow(0 0 18px rgba(78,166,255,.28));
    }
    .ring::after{
      content:"";
      position:absolute;
      inset: 10px;
      border-radius: 999px;
      background: #000;
      border: 1px solid rgba(255,255,255,.08);
      box-shadow: var(--inset);
    }

    .core{
      position: relative;
      z-index: 2;
      width: 210px;
      height: 210px;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 18px 46px rgba(0,0,0,.7), var(--inset);
      display:flex;
      flex-direction: column;
      align-items:center;
      justify-content:center;
      gap: 10px;
      text-align:center;
    }

    .core::before{
      content:"";
      position:absolute;
      inset:-1px;
      border-radius: 999px;
      box-shadow: 0 0 0 1px rgba(255,255,255,.05), 0 0 30px rgba(78,166,255,.22);
      pointer-events:none;
      opacity: .9;
    }

    .actionText{
      font-size: 22px;
      font-weight: 1000;
      letter-spacing: .2px;
    }
    .subText{
      font-size: 12px;
      color: rgba(234,240,255,.78);
      padding: 0 18px;
    }
    .countdown{
      font-size: 34px;
      font-weight: 1000;
      letter-spacing: -0.03em;
      line-height: 1;
    }

    .mainBtn:active .core{ transform: translateY(1px) scale(.995); }

    /* Ripple inteligente: usa --accentColor / --accentGlow (se actualizan según azul/amarillo/rojo) */
    .mainBtn .ripple{
      position:absolute;
      border-radius:999px;
      transform: translate(-50%, -50%);
      animation: ripple 560ms ease-out;
      pointer-events:none;
      opacity:.34;
      background: var(--accentColor);
      filter: drop-shadow(0 0 22px var(--accentGlow));
      mix-blend-mode: screen;
    }
    @keyframes ripple{
      from { width:0; height:0; opacity:.36; }
      to   { width:560px; height:560px; opacity:0; }
    }

    .bottomRow{
      display:flex;
      align-items:flex-start;
      justify-content: space-between;
      gap: 12px;
      padding: 14px;
      border-radius: var(--r);
      background: var(--card);
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
    }

    .waitBtn{
      width: 84px;
      height: 84px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      box-shadow: 0 14px 36px rgba(0,0,0,.66), var(--inset);
      color: var(--text);
      font-weight: 1000;
      cursor:pointer;
      position: relative;
      flex: 0 0 auto;
    }
    .waitBtn::after{
      content:"";
      position:absolute;
      inset:-1px;
      border-radius: 999px;
      box-shadow: 0 0 18px rgba(78,166,255,.28);
      pointer-events:none;
    }
    .waitBtn:active{ transform: translateY(1px) scale(.995); }

    .queueBox{
      flex:1;
      text-align:right;
    }
    .queueIcons{
      display:flex;
      align-items:center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content:flex-end;
      max-width: 320px;
    }
    .person{
      width: 22px;
      height: 22px;
      opacity: .95;
      filter: drop-shadow(0 0 10px rgba(78,166,255,.25));
    }
    .qText{
      font-size: 12px;
      color: rgba(234,240,255,.75);
      margin-top: 6px;
      text-align:right;
    }

    .qList{
      margin-top: 10px;
      display:flex;
      flex-direction: column;
      gap: 8px;
      align-items:stretch;
    }
    .qItem{
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      text-align:left;
    }
    .qItem strong{ display:block; font-size: 13px; margin-bottom: 4px; }
    .qItem .muted{ font-size: 12px; color: rgba(234,240,255,.72); }

    .miniRow{
      display:flex;
      gap: 10px;
      justify-content: space-between;
      align-items:center;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    .miniBtn{
      flex: 1;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      color: var(--text);
      padding: 12px 12px;
      font-weight: 1000;
      box-shadow: var(--inset);
      cursor:pointer;
      min-width: 140px;
    }
    .miniBtnBlue{ border-color: rgba(78,166,255,.35); box-shadow: 0 0 18px rgba(78,166,255,.14), var(--inset); }
    .miniBtnRed{ border-color: rgba(255,78,106,.32); box-shadow: 0 0 18px rgba(255,78,106,.12), var(--inset); }
    .miniBtn:active{ transform: translateY(1px); }

    dialog::backdrop{ background: rgba(0,0,0,.70); }
    dialog{ border:0; padding:0; background: transparent; }
    .sheet{
      width: min(560px, calc(100vw - 26px));
      border-radius: 18px;
      background: rgba(0,0,0,.92);
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .sheet h3{ margin:0 0 8px; font-size: 16px; }
    .sheet h4{ margin:14px 0 8px; font-size: 13px; color: rgba(234,240,255,.9); }
    .sheet .muted{ color: var(--muted); font-size: 12px; }
    .sheet select, .sheet input{
      width: 100%;
      margin-top: 10px;
      background: rgba(255,255,255,.03);
      border: 1px solid rgba(255,255,255,.12);
      color: var(--text);
      border-radius: 14px;
      padding: 12px;
      font-size: 14px;
      outline:none;
      box-shadow: var(--inset);
    }
    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .row{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 12px;
      justify-content:flex-end;
    }
    .btn{
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.04);
      color: var(--text);
      border-radius: 14px;
      padding: 12px 14px;
      font-weight: 1000;
      cursor:pointer;
      box-shadow: var(--inset);
    }
    .btnBlue{ border-color: rgba(78,166,255,.38); box-shadow: 0 0 20px rgba(78,166,255,.18), var(--inset); }
    .btnRed{ border-color: rgba(255,78,106,.35); box-shadow: 0 0 20px rgba(255,78,106,.16), var(--inset); }
    .btn:active{ transform: translateY(1px); }

    .hintLine{
      margin-top: 10px;
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      font-size: 12px;
      color: rgba(234,240,255,.8);
    }

    .logList{
      margin-top: 10px;
      display:flex;
      flex-direction: column;
      gap: 10px;
      max-height: 52vh;
      overflow:auto;
      padding-right: 6px;
    }
    .logItem{
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
    }
    .logItem strong{ display:block; font-size: 13px; margin-bottom: 4px; }
    .logItem .muted{ font-size: 12px; color: rgba(234,240,255,.72); }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="top">
      <div>
        <div class="label">Ahora</div>
        <div class="now" id="now">--:--</div>
        <div class="tiny" id="statusLine">—</div>
        <div class="bgline" id="bgLine"></div>
      </div>

      <div style="text-align:right;">
        <div class="badge">
          <span class="dot" id="dot"></span>
          <span id="statusText">VERDE</span>
        </div>
        <div class="label" style="margin-top:10px;">Salida estimada</div>
        <div class="eta" id="eta">--:--</div>
        <div class="tiny" id="etaExplain"></div>
      </div>
    </div>

    <div class="center">
      <button class="mainBtn" id="mainBtn" aria-label="Iniciar o finalizar">
        <div class="ring" id="ring" style="--p: 0deg; --ringFill: var(--blue);"></div>
        <div class="core">
          <div class="actionText" id="actionText">INICIAR</div>
          <div class="countdown" id="countdown">—</div>
          <div class="subText" id="subText">Tocá para arrancar.</div>
        </div>
      </button>
    </div>

    <div class="bottomRow">
      <button class="waitBtn" id="waitBtn">ESPERA</button>

      <div class="queueBox">
        <div class="queueIcons" id="queueIcons"></div>
        <div class="qText" id="qText">0 en espera</div>
        <div class="qList" id="qList"></div>
      </div>
    </div>

    <div class="miniRow">
      <button class="miniBtn miniBtnRed" id="undoBtn">DESHACER</button>
      <button class="miniBtn miniBtnBlue" id="logBtn">REGISTRO</button>
      <button class="miniBtn" id="settingsBtn">AJUSTES</button>
      <button class="miniBtn miniBtnRed" id="cancelLongBtn">CANCELAR LARGO</button>
      <button class="miniBtn" id="resetLongBtn">RESET LARGO</button>
      <button class="miniBtn miniBtnRed" id="resetAllBtn">RESET TOTAL</button>
    </div>
  </div>

  <dialog id="startDlg">
    <form method="dialog" class="sheet">
      <h3>Iniciar</h3>
      <div class="muted">Elegí el servicio (sin nombres).</div>
      <select id="startService"></select>
      <div class="row">
        <button class="btn" value="cancel">Cancelar</button>
        <button class="btn btnBlue" value="ok">Arrancar</button>
      </div>
      <div class="hintLine">Color/Permanente usan tiempos muertos automáticos (sin avisos).</div>
    </form>
  </dialog>

  <dialog id="finishDlg">
    <form method="dialog" class="sheet">
      <h3>Finalizar</h3>
      <div class="muted" id="finishInfo">—</div>
      <select id="finishService"></select>
      <div class="row">
        <button class="btn" value="cancel">Cancelar</button>
        <button class="btn btnRed" value="ok">Guardar</button>
      </div>
    </form>
  </dialog>

  <dialog id="waitDlg">
    <form method="dialog" class="sheet">
      <h3>Espera</h3>
      <div class="muted" id="waitInfo">—</div>
      <select id="waitService"></select>
      <div class="hintLine" id="waitHint">—</div>
      <div class="row">
        <button class="btn" value="cancel">No se queda</button>
        <button class="btn btnBlue" value="ok">Agregar</button>
      </div>
    </form>
  </dialog>

  <dialog id="overDlg">
    <form method="dialog" class="sheet">
      <h3>Se pasa del cierre</h3>
      <div class="muted" id="overText">—</div>
      <div class="row">
        <button class="btn" value="cancel">No</button>
        <button class="btn btnRed" value="ok">Aceptar igual</button>
      </div>
    </form>
  </dialog>

  <dialog id="settingsDlg">
    <form method="dialog" class="sheet">
      <h3>Ajustes</h3>
      <div class="muted">Turnos + tiempos + promedio automático (min/max → avg).</div>

      <h4>Turnos</h4>
      <div class="grid2">
        <div><div class="muted">Inicio mañana</div><input id="cfgAMStart" type="text" placeholder="09:30"></div>
        <div><div class="muted">Fin mañana</div><input id="cfgAMEnd" type="text" placeholder="13:00"></div>
      </div>
      <div class="grid2" style="margin-top:10px;">
        <div><div class="muted">Inicio tarde</div><input id="cfgPMStart" type="text" placeholder="17:30"></div>
        <div><div class="muted">Fin tarde</div><input id="cfgPMEnd" type="text" placeholder="22:00"></div>
      </div>

      <h4>Límites</h4>
      <div class="grid2">
        <div>
          <div class="muted">Tolerancia (min)</div>
          <input id="cfgHard" type="number" min="0" step="1">
        </div>
        <div>
          <div class="muted">Margen semáforo (min)</div>
          <input id="cfgBuf" type="number" min="0" step="1">
        </div>
      </div>

      <div class="grid2" style="margin-top:10px;">
        <div>
          <div class="muted">Auto-aprendizaje (0 a 1)</div>
          <input id="cfgAuto" type="number" min="0" max="1" step="0.01">
        </div>
        <div>
          <div class="muted">—</div>
          <input disabled value="(usa hora actual)" />
        </div>
      </div>

      <h4>Corte / Barba / Sellado</h4>
      <div class="grid2">
        <div><div class="muted">Corte MIN</div><input id="cutMin" type="number" min="5" step="1"></div>
        <div><div class="muted">Corte MAX</div><input id="cutMax" type="number" min="5" step="1"></div>
      </div>
      <div class="grid2" style="margin-top:10px;">
        <div><div class="muted">Extra Barba MIN</div><input id="beardMin" type="number" min="0" step="1"></div>
        <div><div class="muted">Extra Barba MAX</div><input id="beardMax" type="number" min="0" step="1"></div>
      </div>
      <div class="grid2" style="margin-top:10px;">
        <div><div class="muted">Extra Sellado MIN</div><input id="thermMin" type="number" min="0" step="1"></div>
        <div><div class="muted">Extra Sellado MAX</div><input id="thermMax" type="number" min="0" step="1"></div>
      </div>

      <div class="row">
        <button class="btn btnBlue" id="avgBtn" value="noop">PROMEDIO AUTOMÁTICO</button>
      </div>

      <h4>Color (simple con tiempos muertos)</h4>
      <div class="grid2">
        <div><div class="muted">Prep/Mechas (activo)</div><input id="colPrep" type="number" min="0" step="1"></div>
        <div><div class="muted">Espera 1 (muerto)</div><input id="colWait1" type="number" min="0" step="1"></div>
      </div>
      <div class="grid2" style="margin-top:10px;">
        <div><div class="muted">Cambio (activo)</div><input id="colChange" type="number" min="0" step="1"></div>
        <div><div class="muted">Espera 2 (muerto)</div><input id="colWait2" type="number" min="0" step="1"></div>
      </div>
      <div class="grid2" style="margin-top:10px;">
        <div><div class="muted">Final (activo)</div><input id="colFinal" type="number" min="0" step="1"></div>
        <div><div class="muted">Incluye corte (0/1)</div><input id="colCut" type="number" min="0" max="1" step="1"></div>
      </div>

      <h4>Permanente (simple con tiempos muertos)</h4>
      <div class="grid2">
        <div><div class="muted">Ruleros (activo)</div><input id="perActive1" type="number" min="0" step="1"></div>
        <div><div class="muted">Espera 1 (muerto)</div><input id="perWait1" type="number" min="0" step="1"></div>
      </div>
      <div class="grid2" style="margin-top:10px;">
        <div><div class="muted">Neutralizante (activo)</div><input id="perActive2" type="number" min="0" step="1"></div>
        <div><div class="muted">Espera 2 (muerto)</div><input id="perWait2" type="number" min="0" step="1"></div>
      </div>
      <div class="grid2" style="margin-top:10px;">
        <div><div class="muted">Final (activo)</div><input id="perFinal" type="number" min="0" step="1"></div>
        <div><div class="muted">Incluye corte (0/1)</div><input id="perCut" type="number" min="0" max="1" step="1"></div>
      </div>

      <div class="row">
        <button class="btn" value="cancel">Cerrar</button>
        <button class="btn btnBlue" value="ok">Guardar</button>
      </div>

      <div class="hintLine">
        El color AMARILLO/ROJO se calcula según el turno actual (mañana o tarde).
      </div>
    </form>
  </dialog>

  <dialog id="logDlg">
    <form method="dialog" class="sheet">
      <h3>Registro del día</h3>
      <div class="muted" id="logSummary">—</div>
      <div class="logList" id="logList"></div>
      <div class="row">
        <button class="btn" value="cancel">Cerrar</button>
        <button class="btn btnBlue" id="copyBtn" value="noop">Copiar</button>
        <button class="btn btnRed" id="clearBtn" value="noop">Borrar</button>
      </div>
    </form>
  </dialog>

<script>
/* Helpers */
const pad = n => String(n).padStart(2,'0');
const nowMin = () => { const d=new Date(); return d.getHours()*60+d.getMinutes(); }
const fromMin = (m) => { m=((m%1440)+1440)%1440; return pad(Math.floor(m/60))+':'+pad(m%60); }
const toMin = (hhmm) => { const [h,m]=hhmm.split(':').map(Number); return h*60+m; }
function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
function vibrate(ms){ try{ if(navigator.vibrate) navigator.vibrate(ms);}catch{} }

/* Servicios */
const services = [
  { id:'cut', label:'Corte' },
  { id:'cutbeard', label:'Corte + Barba' },
  { id:'cutbeardthermal', label:'Corte + Barba + Sellado térmico' },
  { id:'color', label:'Color (largo)' },
  { id:'perm', label:'Permanente (largo)' }
];
const svcLabel = Object.fromEntries(services.map(s=>[s.id,s.label]));

/* Estado (localStorage) */
const LS='turnos_minimal_simple_v5';
const load=()=>{ try{return JSON.parse(localStorage.getItem(LS))||null}catch{return null} };
const save=(s)=>localStorage.setItem(LS, JSON.stringify(s));

const defaultState={
  cfg:{
    shiftStartAM:'09:30',
    shiftEndAM:'13:00',
    shiftStartPM:'17:30',
    shiftEndPM:'22:00',
    hardOver:10,
    buffer:12,
    learnAlpha:0.22
  },
  current:null,
  pausedCut:null,
  queue:[],
  long:null,
  log:[],
  seq:1,
  times:{
    cut:{ min:35, max:50, avg:42 },
    beard:{ min:15, max:20, avg:18 },
    thermal:{ min:15, max:25, avg:22 },
    colorSimple:{ prep:40, wait1:45, change:12, wait2:45, final:12, includeCut:1 },
    permSimple:{ active1:60, wait1:45, active2:10, wait2:30, final:10, includeCut:1 }
  }
};

let state = load() || structuredClone(defaultState);

/* Migración por si venías de versiones viejas */
(function migrate(){
  state.cfg ||= {};
  if(!state.cfg.shiftStartAM) state.cfg.shiftStartAM = '09:30';
  if(!state.cfg.shiftEndAM) state.cfg.shiftEndAM = '13:00';
  if(!state.cfg.shiftStartPM) state.cfg.shiftStartPM = '17:30';
  if(!state.cfg.shiftEndPM){
    state.cfg.shiftEndPM = state.cfg.shiftEnd || '22:00';
  }
  if(state.cfg.hardOver == null) state.cfg.hardOver = 10;
  if(state.cfg.buffer == null) state.cfg.buffer = 12;
  if(state.cfg.learnAlpha == null) state.cfg.learnAlpha = 0.22;
})();

/* Cierre dinámico (elige 13:00 o 22:00 según hora) */
function currentShiftEndMin(){
  const now = nowMin();
  const amS = toMin(state.cfg.shiftStartAM);
  const amE = toMin(state.cfg.shiftEndAM);
  const pmS = toMin(state.cfg.shiftStartPM);
  const pmE = toMin(state.cfg.shiftEndPM);

  if(now >= amS && now <= amE) return amE;
  if(now >= pmS && now <= pmE) return pmE;

  if(now < amS) return amE;   // antes de abrir: cierre relevante mañana
  if(now < pmS) return pmE;   // entre turnos: cierre relevante tarde
  return pmE;                 // después: tarde
}
function currentShiftEndText(){ return fromMin(currentShiftEndMin()); }

/* UI refs */
const elNow=document.getElementById('now');
const elEta=document.getElementById('eta');
const elEtaExplain=document.getElementById('etaExplain');
const elStatusText=document.getElementById('statusText');
const elDot=document.getElementById('dot');
const elStatusLine=document.getElementById('statusLine');
const bgLine=document.getElementById('bgLine');

const mainBtn=document.getElementById('mainBtn');
const actionText=document.getElementById('actionText');
const countdown=document.getElementById('countdown');
const subText=document.getElementById('subText');
const ring=document.getElementById('ring');

const waitBtn=document.getElementById('waitBtn');
const queueIcons=document.getElementById('queueIcons');
const qText=document.getElementById('qText');
const qList=document.getElementById('qList');

const undoBtn=document.getElementById('undoBtn');
const logBtn=document.getElementById('logBtn');
const settingsBtn=document.getElementById('settingsBtn');
const cancelLongBtn=document.getElementById('cancelLongBtn');
const resetLongBtn=document.getElementById('resetLongBtn');
const resetAllBtn=document.getElementById('resetAllBtn');

const startDlg=document.getElementById('startDlg');
const startService=document.getElementById('startService');

const finishDlg=document.getElementById('finishDlg');
const finishInfo=document.getElementById('finishInfo');
const finishService=document.getElementById('finishService');

const waitDlg=document.getElementById('waitDlg');
const waitInfo=document.getElementById('waitInfo');
const waitService=document.getElementById('waitService');
const waitHint=document.getElementById('waitHint');

const overDlg=document.getElementById('overDlg');
const overText=document.getElementById('overText');

const settingsDlg=document.getElementById('settingsDlg');
const cfgAMStart=document.getElementById('cfgAMStart');
const cfgAMEnd=document.getElementById('cfgAMEnd');
const cfgPMStart=document.getElementById('cfgPMStart');
const cfgPMEnd=document.getElementById('cfgPMEnd');
const cfgHard=document.getElementById('cfgHard');
const cfgBuf=document.getElementById('cfgBuf');
const cfgAuto=document.getElementById('cfgAuto');

const cutMin=document.getElementById('cutMin');
const cutMax=document.getElementById('cutMax');
const beardMin=document.getElementById('beardMin');
const beardMax=document.getElementById('beardMax');
const thermMin=document.getElementById('thermMin');
const thermMax=document.getElementById('thermMax');
const avgBtn=document.getElementById('avgBtn');

const colPrep=document.getElementById('colPrep');
const colWait1=document.getElementById('colWait1');
const colChange=document.getElementById('colChange');
const colWait2=document.getElementById('colWait2');
const colFinal=document.getElementById('colFinal');
const colCut=document.getElementById('colCut');

const perActive1=document.getElementById('perActive1');
const perWait1=document.getElementById('perWait1');
const perActive2=document.getElementById('perActive2');
const perWait2=document.getElementById('perWait2');
const perFinal=document.getElementById('perFinal');
const perCut=document.getElementById('perCut');

const logDlg=document.getElementById('logDlg');
const logSummary=document.getElementById('logSummary');
const logList=document.getElementById('logList');
const copyBtn=document.getElementById('copyBtn');
const clearBtn=document.getElementById('clearBtn');

/* Fill selects */
function fillServiceSelect(sel){
  sel.innerHTML = services.map(s=>`<option value="${s.id}">${s.label}</option>`).join('');
}
fillServiceSelect(startService);
fillServiceSelect(finishService);
fillServiceSelect(waitService);

/* Estimaciones */
function estFor(service){
  const t = state.times;
  if(service==='cut') return Math.round(t.cut.avg);
  if(service==='cutbeard') return Math.round(t.cut.avg + t.beard.avg);
  if(service==='cutbeardthermal') return Math.round(t.cut.avg + t.beard.avg + t.thermal.avg);
  if(service==='color'){
    const c=t.colorSimple;
    const base = c.prep + c.wait1 + c.change + c.wait2 + c.final;
    return base + (c.includeCut ? Math.round(t.cut.avg) : 0);
  }
  if(service==='perm'){
    const p=t.permSimple;
    const base = p.active1 + p.wait1 + p.active2 + p.wait2 + p.final;
    return base + (p.includeCut ? Math.round(t.cut.avg) : 0);
  }
  return Math.round(t.cut.avg);
}

/* Timer robusto (Date.now) */
function ensureStartedAtMs(){
  if(state.current && !state.current.startedAtMs){
    state.current.startedAtMs = Date.now();
  }
}
function currentActiveMin(){
  if(!state.current) return 0;
  ensureStartedAtMs();
  const elapsedMs = Date.now() - state.current.startedAtMs;
  return Math.max(0, Math.round(elapsedMs / 60000));
}
function currentEstMin(){
  if(!state.current) return 0;
  return (state.current.remainingOverride != null)
    ? state.current.remainingOverride
    : estFor(state.current.service);
}
function currentRemainingMin(){
  if(!state.current) return 0;
  const elapsed = currentActiveMin();
  const est = currentEstMin();
  return Math.round(est - elapsed); // puede ser negativo (demora)
}

/* Largo (fases simples con tiempos muertos, sin avisos) */
function buildLongPhases(type){
  const t=state.times;
  if(type==='color'){
    const c=t.colorSimple;
    const phases = [
      { name:'Prep/Mechas', kind:'active', minutes: c.prep },
      { name:'Espera 1', kind:'wait', minutes: c.wait1 },
      { name:'Cambio', kind:'active', minutes: c.change },
      { name:'Espera 2', kind:'wait', minutes: c.wait2 },
      { name:'Final', kind:'active', minutes: c.final }
    ];
    if(c.includeCut) phases.push({ name:'Corte final', kind:'active', minutes: Math.round(state.times.cut.avg) });
    return phases;
  }
  if(type==='perm'){
    const p=t.permSimple;
    const phases = [
      { name:'Ruleros', kind:'active', minutes: p.active1 },
      { name:'Espera 1', kind:'wait', minutes: p.wait1 },
      { name:'Neutralizante', kind:'active', minutes: p.active2 },
      { name:'Espera 2', kind:'wait', minutes: p.wait2 },
      { name:'Final', kind:'active', minutes: p.final }
    ];
    if(p.includeCut) phases.push({ name:'Corte final', kind:'active', minutes: Math.round(state.times.cut.avg) });
    return phases;
  }
  return [];
}

function startCutFromPaused(service, remainingMin){
  const nowM=nowMin();
  state.current = {
    kind:'cut',
    service,
    startedAtMin: nowM,
    startedAtMs: Date.now(),
    remainingOverride: Math.max(0, remainingMin)
  };
}

function startLong(type){
  const phases = buildLongPhases(type);
  if(!phases.length) return;
  const nowMs = Date.now();
  const nowM = nowMin();
  state.long = { type, phases, i: 0, phaseEndsAtMs: nowMs + phases[0].minutes*60000 };
  state.current = { kind:'longActive', service: type, startedAtMin: nowM, startedAtMs: nowMs, remainingOverride: phases[0].minutes };
}

function longPhase(){
  if(!state.long) return null;
  return state.long.phases[state.long.i] || null;
}

function advanceLong(){
  if(!state.long) return;
  state.long.i++;
  const ph = longPhase();
  if(!ph){ state.long = null; return; }
  state.long.phaseEndsAtMs = Date.now() + ph.minutes*60000;

  if(ph.kind==='active'){
    if(state.current && state.current.kind==='cut'){
      const rem = currentRemainingMin();
      state.pausedCut = { service: state.current.service, remainingMin: rem };
      state.current = null;
    }
    state.current = { kind:'longActive', service: state.long.type, startedAtMin: nowMin(), startedAtMs: Date.now(), remainingOverride: ph.minutes };
  } else {
    if(!state.current && state.pausedCut){
      const c = state.pausedCut;
      state.pausedCut = null;
      startCutFromPaused(c.service, c.remainingMin);
    }
  }
}

function tickLong(){
  if(!state.long) { bgLine.style.display='none'; return; }
  const ph = longPhase();
  if(!ph){ bgLine.style.display='none'; return; }

  const remMin = Math.ceil((state.long.phaseEndsAtMs - Date.now()) / 60000);
  const next = state.long.phases[state.long.i + 1];

  bgLine.style.display='block';
  bgLine.innerHTML = `<strong>${svcLabel[state.long.type]}</strong>: ${ph.name} · ${ph.kind==='wait'?'espera':'activo'} · faltan ${Math.max(0,remMin)}m${next ? ` · luego: ${next.name}` : ''}`;

  if(Date.now() >= state.long.phaseEndsAtMs){
    advanceLong();
  }
}

/* ETA / Semáforo */
function totalRemainingLongMin(){
  if(!state.long) return 0;
  let total = Math.max(0, Math.ceil((state.long.phaseEndsAtMs - Date.now())/60000));
  for(let i=state.long.i+1;i<state.long.phases.length;i++){
    total += state.long.phases[i].minutes;
  }
  return total;
}

function etaFinishMin(){
  const nowM=nowMin();
  let t = nowM;

  if(state.current){
    t += Math.max(0, currentRemainingMin());
  }

  if(state.long){
    let longRem = totalRemainingLongMin();
    if(state.current && state.current.kind==='longActive'){
      const phRem = Math.max(0, Math.ceil((state.long.phaseEndsAtMs - Date.now())/60000));
      longRem = Math.max(0, longRem - phRem);
    }
    t += longRem;
  }

  if(state.pausedCut) t += Math.max(0, state.pausedCut.remainingMin);
  for(const q of state.queue) t += estFor(q.service);
  return t;
}

function statusFor(eta){
  const end = currentShiftEndMin();
  const hard = end + state.cfg.hardOver;
  const buf = state.cfg.buffer;
  const etaBuf = eta + buf;

  if(etaBuf<=end) return {label:'VERDE', color:'var(--green)', explain:`Con margen (+${buf}) terminás ${fromMin(etaBuf)}. Cierre: ${currentShiftEndText()}`};
  if(etaBuf<=hard) return {label:'AMARILLO', color:'var(--amber)', explain:`Te pasás un poco. Con margen: ${fromMin(etaBuf)}. Cierre: ${currentShiftEndText()}`};
  return {label:'ROJO', color:'var(--red)', explain:`No entra más. Con margen: ${fromMin(etaBuf)}. Cierre: ${currentShiftEndText()}`};
}

/* Próximo corte (para colorear INICIAR: azul/amarillo/rojo según turno actual) */
function nextCutFitStatus(){
  const now = nowMin();
  const end = currentShiftEndMin();
  const hard = end + Number(state.cfg.hardOver || 0);
  const cutEst = estFor('cut');

  let occupied = 0;
  if(state.current) occupied += Math.max(0, currentRemainingMin());

  if(state.long){
    let longRem = totalRemainingLongMin();
    if(state.current && state.current.kind==='longActive'){
      const phRem = Math.max(0, Math.ceil((state.long.phaseEndsAtMs - Date.now())/60000));
      longRem = Math.max(0, longRem - phRem);
    }
    occupied += longRem;
  }

  if(state.pausedCut) occupied += Math.max(0, state.pausedCut.remainingMin);
  for(const q of state.queue) occupied += estFor(q.service);

  const start = now + occupied;
  const finish = start + cutEst;

  if(finish <= end) return { status:'blue', start, finish, end, hard };
  if(finish <= hard) return { status:'yellow', start, finish, end, hard };
  return { status:'red', start, finish, end, hard };
}

/* Cola UI */
function personSvg(){
  return `
  <svg class="person" viewBox="0 0 24 24" fill="none" aria-hidden="true">
    <path d="M12 12.2c2.4 0 4.3-2 4.3-4.4S14.4 3.4 12 3.4 7.7 5.4 7.7 7.8 9.6 12.2 12 12.2Z"
      stroke="rgba(78,166,255,.95)" stroke-width="1.6"/>
    <path d="M4.6 20.6c.9-4 4-6.2 7.4-6.2s6.5 2.2 7.4 6.2"
      stroke="rgba(78,166,255,.95)" stroke-width="1.6" stroke-linecap="round"/>
  </svg>`;
}

function estimateStartEndForQueue(){
  const baseStart = etaFinishMin();
  let cursor = baseStart;
  const items=[];
  for(const q of state.queue){
    const s=cursor;
    const e=s + estFor(q.service);
    items.push({service:q.service, start:s, end:e});
    cursor=e;
  }
  return items;
}

function renderQueue(){
  const n = state.queue.length;
  queueIcons.innerHTML = '';
  for(let i=0;i<Math.min(n,12);i++){
    const wrap=document.createElement('div');
    wrap.innerHTML = personSvg();
    queueIcons.appendChild(wrap.firstElementChild);
  }
  qText.textContent = `${n} en espera`;

  const items = estimateStartEndForQueue();
  qList.innerHTML = '';
  for(const s of items){
    const div=document.createElement('div');
    div.className='qItem';
    div.innerHTML = `<strong>${svcLabel[s.service] || s.service}</strong>
      <div class="muted">Inicia ${fromMin(s.start)} · Sale ${fromMin(s.end)}</div>`;
    qList.appendChild(div);
  }
}

/* Ring (progreso) */
function setRingProgress(pct){
  const deg = Math.max(0, Math.min(1, pct)) * 360;
  ring.style.setProperty('--p', `${deg}deg`);
}

/* Acento (afecta ring + ripple) */
function setAccent(kind){
  if(kind==='blue'){
    mainBtn.style.setProperty('--accentColor','rgba(78,166,255,.95)');
    mainBtn.style.setProperty('--accentGlow','rgba(78,166,255,.38)');
    ring.style.filter = 'drop-shadow(0 0 18px rgba(78,166,255,.28))';
    ring.style.setProperty('--ringFill','var(--blue)');
    return;
  }
  if(kind==='yellow'){
    mainBtn.style.setProperty('--accentColor','rgba(255,212,90,.95)');
    mainBtn.style.setProperty('--accentGlow','rgba(255,212,90,.36)');
    ring.style.filter = 'drop-shadow(0 0 18px rgba(255,212,90,.30))';
    ring.style.setProperty('--ringFill','var(--amber)');
    return;
  }
  if(kind==='red'){
    mainBtn.style.setProperty('--accentColor','rgba(255,78,106,.95)');
    mainBtn.style.setProperty('--accentGlow','rgba(255,78,106,.40)');
    ring.style.filter = 'drop-shadow(0 0 18px rgba(255,78,106,.35))';
    ring.style.setProperty('--ringFill','var(--red)');
    return;
  }
}

/* Registro */
function renderLog(){
  const items = state.log || [];
  const total = items.length;
  const totalMin = items.reduce((a,x)=>a+(x.durationMin||0),0);
  logSummary.textContent = `${total} servicios · ${totalMin} min`;

  logList.innerHTML = '';
  if(!items.length){
    logList.innerHTML = `<div class="logItem"><div class="muted">Aún no hay registros.</div></div>`;
    return;
  }
  for(const h of items.slice().reverse()){
    const svc = svcLabel[h.service] || h.service;
    const line = `${fromMin(h.startMin)}-${fromMin(h.endMin)} · ${h.durationMin}m · ${svc}`;
    const div=document.createElement('div');
    div.className='logItem';
    div.innerHTML = `<strong>${svc}</strong><div class="muted">${line}</div>`;
    logList.appendChild(div);
  }
}
function logToText(){
  const items = state.log || [];
  return items.map(h=>{
    const svc = h.service;
    return `${fromMin(h.startMin)}-${fromMin(h.endMin)} | ${svcLabel[svc]||svc} | ${h.durationMin}min`;
  }).join('\n');
}

/* Render */
function render(){
  tickLong();
  renderQueue();

  const now=nowMin();
  elNow.textContent = fromMin(now);

  const eta=etaFinishMin();
  elEta.textContent = fromMin(eta);
  const st=statusFor(eta);

  elStatusText.textContent = st.label;
  elDot.style.background = st.color;
  elDot.style.boxShadow = `0 0 18px ${st.color}`;
  elEtaExplain.textContent = st.explain;

  const longTxt = state.long ? ` · ${svcLabel[state.long.type]}` : '';
  const pausedTxt = state.pausedCut ? ` · Corte pausado (${state.pausedCut.remainingMin}m)` : '';

  const hasLong = !!state.long || (state.current && state.current.kind==='longActive');
  cancelLongBtn.style.display = hasLong ? 'inline-block' : 'none';

  if(!state.current){
    actionText.textContent = 'INICIAR';
    countdown.textContent = '—';
    setRingProgress(0);

    const f = nextCutFitStatus();
    if(f.status==='blue'){
      setAccent('blue');
      subText.textContent = state.queue.length
        ? `Hay ${state.queue.length} en espera.`
        : `Entra un corte: ${fromMin(f.start)}–${fromMin(f.finish)} (cierre ${currentShiftEndText()}).`;
    } else if(f.status==='yellow'){
      setAccent('yellow');
      subText.textContent = `Entra JUSTO: ${fromMin(f.start)}–${fromMin(f.finish)} (cierre ${currentShiftEndText()}).`;
    } else {
      setAccent('red');
      subText.textContent = `No entra: terminarías ${fromMin(f.finish)} (cierre ${currentShiftEndText()}).`;
    }

    elStatusLine.textContent = `Libre${longTxt}${pausedTxt}`;
  } else {
    actionText.textContent = 'FINALIZAR';
    setAccent('red');

    const rem=currentRemainingMin();
    countdown.textContent = (rem>=0) ? `${rem}m` : `+${Math.abs(rem)}m`;

    const label = (state.current.kind==='longActive')
      ? `${svcLabel[state.long?.type] || 'Largo'} (fase activa)`
      : (svcLabel[state.current.service] || state.current.service);

    ensureStartedAtMs();
    const est = currentEstMin();
    const endMs = state.current.startedAtMs + est*60000;
    const endDate = new Date(endMs);
    const fin = endDate.getHours()*60 + endDate.getMinutes();

    subText.textContent = `Estimado ${fromMin(fin)} · ${label}`;

    const done = currentActiveMin();
    setRingProgress(done / Math.max(1, est));
    elStatusLine.textContent = `En curso${longTxt}${pausedTxt}`;
  }

  undoBtn.disabled = state.queue.length===0;
  undoBtn.style.opacity = undoBtn.disabled ? 0.45 : 1;

  save(state);
}

/* Ripple inteligente + lógica principal */
function spawnRipple(e){
  const r = document.createElement('span');
  r.className = 'ripple';
  const rect = mainBtn.getBoundingClientRect();
  r.style.left = (e.clientX - rect.left) + 'px';
  r.style.top  = (e.clientY - rect.top) + 'px';
  mainBtn.appendChild(r);
  r.addEventListener('animationend', () => r.remove());
}

mainBtn.addEventListener('click', (e) => {
  spawnRipple(e);

  if(!state.current){
    startService.value = 'cut';
    startDlg.showModal();
  } else {
    const active = Math.max(1, currentActiveMin());
    finishInfo.textContent = `Tiempo activo: ${active} min`;
    if(state.current.kind==='longActive') finishService.value = state.long?.type || 'color';
    else finishService.value = state.current.service || 'cut';
    finishDlg.showModal();
  }
});

startDlg.addEventListener('close', () => {
  if(startDlg.returnValue!=='ok') return;

  const service = startService.value || 'cut';
  if(service==='color' || service==='perm'){
    startLong(service);
    vibrate(80);
    render();
    return;
  }

  const nowM=nowMin();
  state.current = { kind:'cut', service, startedAtMin: nowM, startedAtMs: Date.now() };
  vibrate(60);
  render();
});

finishDlg.addEventListener('close', () => {
  if(finishDlg.returnValue!=='ok') return;
  if(!state.current) return;

  const done = Math.max(1, currentActiveMin());
  let service = finishService.value || 'cut';

  if(state.current.kind==='longActive'){
    service = state.long?.type || service;

    const total = estFor(service);
    const endMin = nowMin();
    const startMin = endMin - total;
    state.log.push({ id: state.seq++, service, startMin, endMin, durationMin: total });

    state.long = null;
    state.current = null;

    if(state.pausedCut){
      const c=state.pausedCut; state.pausedCut=null;
      startCutFromPaused(c.service, c.remainingMin);
    }

    vibrate(90);
    render();
    return;
  }

  const a = clamp(Number(state.cfg.learnAlpha || 0.22), 0, 1);
  if(a>0){
    const t=state.times;
    if(service==='cut'){
      const obs = clamp(done, t.cut.min, t.cut.max);
      t.cut.avg = (1-a)*t.cut.avg + a*obs;
    } else if(service==='cutbeard'){
      const baseObs = clamp(done - t.beard.avg, t.cut.min, t.cut.max);
      t.cut.avg = (1-a)*t.cut.avg + a*baseObs;
      const extraObs = clamp(done - t.cut.avg, t.beard.min, t.beard.max);
      t.beard.avg = (1-a)*t.beard.avg + a*extraObs;
    } else if(service==='cutbeardthermal'){
      const baseObs = clamp(done - t.beard.avg - t.thermal.avg, t.cut.min, t.cut.max);
      t.cut.avg = (1-a)*t.cut.avg + a*baseObs;
      const beardObs = clamp((done - t.cut.avg) * 0.45, t.beard.min, t.beard.max);
      const thermObs = clamp((done - t.cut.avg) * 0.55, t.thermal.min, t.thermal.max);
      t.beard.avg = (1-a)*t.beard.avg + a*beardObs;
      t.thermal.avg = (1-a)*t.thermal.avg + a*thermObs;
    }
  }

  const startMin = state.current.startedAtMin ?? nowMin();
  const endMin = nowMin();
  state.log.push({ id: state.seq++, service, startMin, endMin, durationMin: done });

  state.current = null;
  vibrate(80);

  // Auto-iniciar el siguiente en cola (si existe) al terminar
  if(state.queue.length){
    const next = state.queue.shift();
    const nowM = nowMin();
    state.current = { kind:'cut', service: next.service, startedAtMin: nowM, startedAtMs: Date.now() };
  }

  render();
});

/* Espera + confirmación cierre */
let pendingAdd = null;

function projectedEndIfAdd(service){
  const start = etaFinishMin();
  const end = start + estFor(service);
  return {start, end};
}

waitBtn.addEventListener('click', () => {
  const rem = state.current ? currentRemainingMin() : 0;

  let finTxt = '';
  if(state.current){
    ensureStartedAtMs();
    const est = currentEstMin();
    const endMs = state.current.startedAtMs + est*60000;
    const d = new Date(endMs);
    finTxt = fromMin(d.getHours()*60 + d.getMinutes());
  }

  waitInfo.textContent = state.current
    ? `Estimado del actual: ${finTxt}. Te quedan ${rem>=0?rem:('+ '+Math.abs(rem))} min.`
    : `No hay corte activo. Esto agrega a la cola.`;

  waitService.value = 'cut';
  const p = projectedEndIfAdd(waitService.value);
  waitHint.textContent = `Si lo agregás: inicia ${fromMin(p.start)} · sale ${fromMin(p.end)}.`;
  waitDlg.showModal();
});

waitService.addEventListener('change', () => {
  const p = projectedEndIfAdd(waitService.value);
  waitHint.textContent = `Si lo agregás: inicia ${fromMin(p.start)} · sale ${fromMin(p.end)}.`;
});

waitDlg.addEventListener('close', () => {
  if(waitDlg.returnValue!=='ok') return;

  const service = waitService.value || 'cut';
  const p = projectedEndIfAdd(service);

  const end = currentShiftEndMin();
  if(p.end > end){
    pendingAdd = { service, p };
    overText.textContent = `Este turno terminaría a ${fromMin(p.end)} (cierre ${currentShiftEndText()}). ¿Aceptar igual?`;
    overDlg.showModal();
    return;
  }

  state.queue.push({ id: state.seq++, service });
  vibrate(80);
  render();
});

overDlg.addEventListener('close', () => {
  if(overDlg.returnValue!=='ok'){ pendingAdd = null; return; }
  if(!pendingAdd) return;

  const end = currentShiftEndMin();
  const hard = end + state.cfg.hardOver;
  if(pendingAdd.p.end > hard){
    pendingAdd = null;
    vibrate(120);
    return;
  }

  state.queue.push({ id: state.seq++, service: pendingAdd.service });
  pendingAdd = null;
  vibrate(120);
  render();
});

/* Deshacer */
undoBtn.addEventListener('click', () => {
  if(!state.queue.length) return;
  state.queue.pop();
  vibrate(60);
  render();
});

/* Cancelar / Reset largo */
function cancelLongOnly(){
  state.long = null;
  if(state.current && state.current.kind==='longActive') state.current = null;

  if(!state.current && state.pausedCut){
    const c = state.pausedCut; state.pausedCut = null;
    startCutFromPaused(c.service, c.remainingMin);
  }
  bgLine.style.display='none';
}

cancelLongBtn.addEventListener('click', () => {
  const hasLong = !!state.long || (state.current && state.current.kind==='longActive');
  if(!hasLong){ alert('No hay Color/Permanente activo.'); return; }
  if(!confirm('Cancelar Color/Permanente activo (sin borrar registro ni aprendizaje)?')) return;
  cancelLongOnly();
  vibrate(120);
  render();
});

resetLongBtn.addEventListener('click', () => {
  const hasLong = !!state.long || (state.current && state.current.kind==='longActive');
  if(!hasLong){ alert('No hay trabajo largo activo.'); return; }
  if(!confirm('Resetear solo el trabajo largo (Color/Permanente) sin tocar cola, registro ni aprendizaje?')) return;
  cancelLongOnly();
  vibrate(120);
  render();
});

/* Reset total (sin borrar aprendizaje ni registro) */
resetAllBtn.addEventListener('click', () => {
  if(!confirm('RESET TOTAL operativo: cancela corte, cola y largos. NO borra registro ni aprendizaje. ¿Confirmás?')) return;
  state.current = null;
  state.long = null;
  state.pausedCut = null;
  state.queue = [];
  bgLine.style.display='none';
  vibrate(180);
  render();
});

/* Registro */
logBtn.addEventListener('click', () => {
  renderLog();
  logDlg.showModal();
});

copyBtn.addEventListener('click', async (e) => {
  e.preventDefault();
  const text = logToText();
  try{
    await navigator.clipboard.writeText(text || '');
    vibrate(120);
    copyBtn.textContent = 'Copiado';
    setTimeout(()=>copyBtn.textContent='Copiar', 700);
  }catch{
    copyBtn.textContent = 'No se pudo';
    setTimeout(()=>copyBtn.textContent='Copiar', 900);
  }
});

clearBtn.addEventListener('click', (e) => {
  e.preventDefault();
  if(!confirm('¿Borrar el registro del día? (no toca aprendizaje)')) return;
  state.log = [];
  renderLog();
  vibrate(120);
  render();
});

/* Ajustes */
function openSettings(){
  cfgAMStart.value = state.cfg.shiftStartAM;
  cfgAMEnd.value = state.cfg.shiftEndAM;
  cfgPMStart.value = state.cfg.shiftStartPM;
  cfgPMEnd.value = state.cfg.shiftEndPM;

  cfgHard.value = state.cfg.hardOver;
  cfgBuf.value = state.cfg.buffer;
  cfgAuto.value = state.cfg.learnAlpha ?? 0.22;

  cutMin.value = state.times.cut.min;
  cutMax.value = state.times.cut.max;
  beardMin.value = state.times.beard.min;
  beardMax.value = state.times.beard.max;
  thermMin.value = state.times.thermal.min;
  thermMax.value = state.times.thermal.max;

  colPrep.value = state.times.colorSimple.prep;
  colWait1.value = state.times.colorSimple.wait1;
  colChange.value = state.times.colorSimple.change;
  colWait2.value = state.times.colorSimple.wait2;
  colFinal.value = state.times.colorSimple.final;
  colCut.value = state.times.colorSimple.includeCut;

  perActive1.value = state.times.permSimple.active1;
  perWait1.value = state.times.permSimple.wait1;
  perActive2.value = state.times.permSimple.active2;
  perWait2.value = state.times.permSimple.wait2;
  perFinal.value = state.times.permSimple.final;
  perCut.value = state.times.permSimple.includeCut;

  settingsDlg.showModal();
}
settingsBtn.addEventListener('click', openSettings);

avgBtn.addEventListener('click', (e) => {
  e.preventDefault();
  state.times.cut.avg = (Number(cutMin.value)+Number(cutMax.value))/2;
  state.times.beard.avg = (Number(beardMin.value)+Number(beardMax.value))/2;
  state.times.thermal.avg = (Number(thermMin.value)+Number(thermMax.value))/2;
  vibrate(60);
});

settingsDlg.addEventListener('close', () => {
  if(settingsDlg.returnValue!=='ok') return;

  state.cfg.shiftStartAM = (cfgAMStart.value||'09:30').trim();
  state.cfg.shiftEndAM = (cfgAMEnd.value||'13:00').trim();
  state.cfg.shiftStartPM = (cfgPMStart.value||'17:30').trim();
  state.cfg.shiftEndPM = (cfgPMEnd.value||'22:00').trim();

  state.cfg.hardOver = Number(cfgHard.value||10);
  state.cfg.buffer = Number(cfgBuf.value||12);
  state.cfg.learnAlpha = clamp(Number(cfgAuto.value||0.22), 0, 1);

  state.times.cut.min = Number(cutMin.value||35);
  state.times.cut.max = Number(cutMax.value||50);
  state.times.beard.min = Number(beardMin.value||15);
  state.times.beard.max = Number(beardMax.value||20);
  state.times.thermal.min = Number(thermMin.value||15);
  state.times.thermal.max = Number(thermMax.value||25);

  state.times.cut.avg = clamp(state.times.cut.avg, state.times.cut.min, state.times.cut.max);
  state.times.beard.avg = clamp(state.times.beard.avg, state.times.beard.min, state.times.beard.max);
  state.times.thermal.avg = clamp(state.times.thermal.avg, state.times.thermal.min, state.times.thermal.max);

  state.times.colorSimple = {
    prep:Number(colPrep.value||40),
    wait1:Number(colWait1.value||45),
    change:Number(colChange.value||12),
    wait2:Number(colWait2.value||45),
    final:Number(colFinal.value||12),
    includeCut: Number(colCut.value||1) ? 1 : 0
  };

  state.times.permSimple = {
    active1:Number(perActive1.value||60),
    wait1:Number(perWait1.value||45),
    active2:Number(perActive2.value||10),
    wait2:Number(perWait2.value||30),
    final:Number(perFinal.value||10),
    includeCut: Number(perCut.value||1) ? 1 : 0
  };

  vibrate(80);
  render();
});

/* Service Worker (PWA) */
if('serviceWorker' in navigator){
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js').catch(()=>{});
  });
}

/* Tick */
setInterval(render, 2000);
render();
</script>
</body>
</html>
